2013-10-19 (noon)
----------

A tiny bit of planning is needed at this point.

I now want to introduce "streamable" properties to the Model concept (Streamable interface). In order to test this, the test suite functions need to be informed about which field(s) implement that concept.

So, I think I should change and normalize the signatures of the test suites a bit. Maybe an "options" parameter will do the trick.

Options, for both test suites (for read-only and for writeable models):
- ref_object      (mandatory)       contains the "raw" JavaScript object to compare the model against
- streamables     (optional)        array with the objects, each containing a field name and its reference content (name, content)

Should a distinction be made between binary and text Streamables? I think not; that would just be unnecessary complexity.

Ok, next step: change those signatures. ... done. But I forgot the collections:

- ref_items       (mandatory)
- new_items       (optional)        for the "writeable" test suite

Ok, back to implementing streamable tests.

2013-10-19
----------

Took way too long again tonight - not sure why this time. The tmp library may have been the cause (removed now).


2013-10-17
----------

Some progress today - though I got slowed down by a stupid mistake, once more. But: I have a working test subroutine for the read-only part of the new Streamable interface, and a test for that testsuite, using a mock-up Streamable object based on q-io/fs.

Found out about the extremely useful before(), after(), beforeEach() and afterEach() functions of Mocha (or was it Should?).

Next steps: 

- move the new test suite to the test-lib folder
- separate out the test suite testing code into a sub-folder "test" within test-lib ?
- create another test suite for writeable Streamables


2013-10-14
----------

Wanted to dive right into this "large property" business, but (thankfully) did some research first.

I think the answer is that Object#get() should deliver "large" values as "stream"-based objects, following the standard established by Kris Kowalski's q-io library, which defines Readers and Writers.

Therefore, Object#get() should return an object that implements an interface I shall call "Streamable", offering a single method open(). That method should take an option argument loosely following its definition in q-io/fs; meaning that it should accept:
  1) a "flags" property, which however must only implement the "w" and "r" values. In fact, a read-only collection should not accept the values "w" or "a" (though I will not require that an exception be thrown in such cases)
  2) a "charset" property, which shall accept (at minimum) the values "utf-8" (the default if omitted) and "binary".

Streamable#open() shall return an object conforming to the Reader or Writer interface as defined by q-io.

Another question: how can user code know whether the property it get()s is a value or a Streamable ?

The argument could be made that user code should know what type each Object property must contain. Right now I'm tending to follow that argument. [Note: the test case for Object#getAll() will have to be updated. It will need to be able to detect Buffer objects in the reference object, which shall be used as the "raw" representations of large data.]

Next steps:

1) model-tests.js: implement a test suite for the Streamable interface - or actually two of them, one read-only, the other writing. Integrate these suites into the testReadOnlyObject() and testObject() suites. The test suites shall test both utf-8 and binary encoding.

1b) (option) use q-io/fs to test the Streamable test suites.

2) Extend ObjectWrapper to support ArrayBuffer fields (i.e. wrapping them into Streamables)


2013-10-13
----------

Some more work today. I decided to implement removal from Collections through their items, i.e. CollectionItem#remove() and (as a side effect) CollectionItem#dispose().

This approach does not require an index into a collection.

I'm rather happy with the way this is taking shape.

The time may be ripe to tackle a filesystem-based implementation.

Or maybe not - first I need to figure out how to handle large properties (text and binary).

2013-10-01
----------

I just successfully implemented the first test case for what will become the JPMVC Object "interface" (I say successfully because, because I'm using promises inside the test routines, and I wasn't at all sure whether that would work). 

I'm using quotation marks for the word "interface" here because interfaces are not part of the JavaScript language.
Actually, my intent is to sort of "replace" formal interface definitions with the test cases I have just begun (see test-lib/model-tests.js). The idea is that these tests will an instance of a model together with a "raw" JavaScript object or array, then execute test cases using the raw object as a reference to compare against. Hopefully, this pattern *should* adapt to all future implementations of the Object and Collection interfaces.

One uncertainty bothering me right now is whether or not to define the whole interfaces as promise-based. Disadvantages: for synchronous implementations, wrapping the results in promises is both a waste of cycles and a way to render even trivial code hard to read. Advantage: a predictable and clear interface.

Right now, I think the way to go is to allow both synchronous and promise-based operation, and making it part of the specification to use Q.when() on all functions UNLESS the programmer can be sure that the particular implementation being used is synchronous.
This has drawbacks too - it's a classical trap producing code that fails when you least expect it (writing with a sychronous interface in mind, then replacing it with an asynchronous one).

Alternatives:
	a) use dual methods, adding "Sync" to synchronous versions of the methods (drawbacks: long, ugly - and what if the implementation can't support synchronous?)
	b) define synchronous and asynchronous versions of the interfaces (the "wrapper" implementations would then likely be the only ones to support both, or exist in both forms)

I'm tending for (b) right now. Not quite happy with it though - what if certain operations could be done synchronously, but not others? get()/set() could arguably always be implemented
synchronously except for blobs - though that last exception, any exception, renders the other cases sort of moot.

Ok. The safe choice is asynchronous, always. To make things nicer, how about sget() and sset() (s for synchronous), which will throw exceptions if not supported? This will make it much less likely to program doomed-to-fail-in-the-future code. [Note to myself: program tests such that synchronous methods must either deliver the expected result right away, or throw an exception.]

2013-09-29
----------

The test suite works. Yet I feel somewhat less than satisfied. One reason is that I still go back-and-forth on some design decisions. Could be a sign that I'm still in the experimental stage, and that a redesign will have to come later on. Note to myself: I will now take note of uncertainties, then leave them be.

Uncertainties: 

- some method names
	
- whether some methods are needed at all

- how far to treat arrays and objects similarly, and where to make a clear distinction (current state: separate Wrapper classes with a common ancestor)
	
- how to handle collections in such a way that support for large, non-indexed collections won't become impractical later on

- whether the cache can be considered efficient enough, even for a first attempt

- whether I should try right away to create implementation-independent tests for Object and Collection "interfaces", or wait till the object wrapper is complete.

All in all though, I'm please at this first step toward building a real Model-View-Controller library.

Things left to do: Collection#addNewObject(); decide whether to support arrays of non-object values through a "virtual" property, or simply let them be arrays (tending towards the latter right now).

I wrote up some notes today regarding the implementation of a filesystem adapter library. No need to write it all down here, but the basic principle is make a Collection out of a directory; Objects out of JSON files; and binary files into blob properties (buffers).

Next steps:

- Implement Collection#newItem(), complete with notifications